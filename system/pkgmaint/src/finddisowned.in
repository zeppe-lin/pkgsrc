#!/bin/sh
# See COPYING and COPYRIGHT files for corresponding information.

finddisowned() {
	# XXX really print to stdout&stderr?
	echo "Get all known files..." 1>&2

	sort -u "$ROOT/var/lib/pkg/db" > "$TMPFILE1"

	#PATHS=$(xargs < "$(readlink -f "$CONFIG")")
	while read -r _path; do
		# skip comments and empty lines
		case $_path in \#* | "" ) continue ;; esac

		PATHS="$PATHS $_path"
	done < "$(readlink -f "$CONFIG")"

	echo "Get paths from config..." 1>&2

	(cd "${ROOT:-/}" || exit 1
	# Intentional.
	# shellcheck disable=2086
	find $PATHS \( -type d -printf '%p/\n' -o -print \) \
		| sort > "$TMPFILE2")

	comm -23 "$TMPFILE2" "$TMPFILE1"
}

print_help() {
	cat <<EOF
Usage: finddisowned [OPTION]
Find files that are disowned by package manager.

  -r, --root PATH     specify alternative root directory
  -c, --config FILE   use an alternate config file
  -v, --version       print version and exit
  -h, --help          print help and exit
EOF
}

main() {
	while [ "$1" ]; do
		case $1 in
		-r|--root)
			if [ ! "$2" ]; then
				error "option $1 requires an argument"
				exit 1
			fi
			ROOT=$2
			shift
			;;
		-c|--config)
			if [ ! "$2" ]; then
				error "option $1 requires an argument"
				exit 1
			fi
			CONFIG=$2
			shift
			;;
		-v|--version)
			echo "finddisowned (pkgmaint) @VERSION@"
			exit 0
			;;
		-h|--help)
			print_help
			exit 0
			;;
		*)
			error "invalid option $1"
			exit 1
			;;
		esac
		shift
	done

	CONFIG=${CONFIG:-"$ROOT/etc/finddisowned.conf"}
	if [ ! -e "$CONFIG" ]; then
		error "can't find $CONFIG file"
		exit 2
	fi

	finddisowned
}

error() {
	echo "finddisowned: $1" >/dev/stderr
}

interrupted() {
	echo "=======> Aborted."
	exit 1
}

atexit() {
	[ -f "$TMPFILE1" ] && rm "$TMPFILE1"
	[ -f "$TMPFILE2" ] && rm "$TMPFILE2"
}

trap "interrupted" HUP INT QUIT TERM
trap "atexit" EXIT

export LC_ALL=POSIX

TMPFILE1=$(mktemp)
TMPFILE2=$(mktemp)

main "$@"

# End of file.
